const crypto = require("crypto")
const redis = require('redis')
require('bluebird').promisifyAll(redis.RedisClient.prototype)

/**
  * @class CommentSet - a single Redis Set of comments.
  *
  * Comments are just strings defined in the format:
  *   `${id}:${user}:${position}:${dateMod}:${deleted}:${content}`
  *       id - {string} unique hex id for this comment, use this to delete a comment
  *       position - {int} the position in the paste this comment is at
  *       dateMod - {UNIX timestamp} the last modified date of this comment
  *       deleted - {0 or 1}, whether this is deleted
  *       content - {string} the content of this comment
  *
  * The id is generated by the node crypto library to help prevent collisions, but can
  * also be assigned by the user when addComment is called.
  *
  * The comment set itself should be created along with a paste. The key is stored as
  *   `comment:${key}`
  *
  * So in the system, the key for a comment set key matches the key for a paste.
  *
  */

class CommentSet {

  /**
    * @constructor (key) - creates a new CommentSet with the given key
    *
    * @property {String} title - a combination of comment:${key}. Key for this Set in Redis
    * @property {String} key - the key for the Paste belongs to
    *
    * @throws Error('Every CommentSet requires a key') - if key is not provided
    * @throws Error('Keys cannot include a colon') - if key includes a colon
    *
    */

  constructor(key) {
    if (!key){
      throw new Error('Every CommentSet requires a key')
    }

    if (key.includes(':')) {
      throw new Error('Keys cannot include a colon')
    }

    this.key = key
    this.title = `comment:${key}`
  }

  /**
    * @static numFields - the number of total fields the Comment has
    */

  static get numFields() {
    return 6;
  }

  /**
    * @static fields - the possible field values for a comment
    */

  static get fields() {
    return  ['id', 'user', 'position', 'dateModified', 'deleted', 'content']
  }

  /**
    * @function addComment - adds a comment to the set
    *
    * @param client - node-redis instance to call redis functions on
    * @param props - properties about the comment
    * @param props.user - the user who made this comment
    * @param props.position - the position in the Paste for this comment
    * @param props.content - the actual comment content
    * @param [optional] props.givenId - an ID to assign to this comment
    *
    * @returns {boolean} if this was successful
    * @throws Error('Could not commit comment ${e}') - something went wrong
    *
    */

  async addComment(client, props = {user, position, content, givenId=undefined}){
    const id = givenId || crypto.randomBytes(8).toString("hex");

    if (this.commentExists(client, id)){
      return this.editComment(client, id, {user, position, content})
    }

    const dateModified = Math.floor(new Date() / 1000).toString()

    const comment = `${id}:${user}:${position}:${dateModified}:0:${content}`

    let result;

    try {
      console.log(`Committing new comment: ${id} at ${position} from ${user}`)
      result = await client.saddAsync(this.title, comment)
      return result === 1;
    } catch (e) {
      throw new Error(`Could not commit comment: ${e}`)
    }
  }

  /**
    * @function editComment - edits a comment given an id
    *
    * @param {RedisClient} client - node-redis instance to call redis functions on
    * @param {String} id - the id of the comment to edit
    * @param {Object} edits - the set of edits to make
    *
    * @returns {boolean} - true if this was successful
    *
    * @throws Error('No comment with ID ${e}') - no comment
    * @throws Error('Invalid field edits ${result}')
    * @throws Error('Could not edit comment ${e}') - Redis problem
    *
    */

  async editComment(client, id, edits){
    try {
      let result = await this.iterateThroughSet(client, 0, `${id}:*`)

      if (result.length < 0){
        throw new Error(`No comment with ID: ${id}`)
      } else {
        // result will be an array of array of strings from sscan
        result = result[0][0]
      }

      const removed = await client.sremAsync(this.title, result)
      const splitSet = result.split(':')

      if (splitSet.length < Comment.numFields{
        throw new Error('Invalid field edits ${result}')
      }

      Object.entries(edits).map(entry => {
        const keyIndex = Comment.fields.indexOf(entry[0])
        if (keyIndex !== -1){
          splitSet[keyIndex] = entry[1]
        }
      })

      splitSet[3] = Math.floor(new Date() / 1000).toString()
      const addResult = await client.saddAsync(this.title, splitSet.join(':'))
      return addResult === 1
    } catch (e) {
      throw new Error(`Could not edit comment: ${e}`)
    }
  }

  /**
    * @function iterateThroughSet - returns all comments matching the given pattern
    *
    * @param {RedisClient} client - active Redis client
    * @param {cursor} cursor - See Redis documentation, this method always goes through entire set if '0' is passed
    * @param {str} pattern - pattern to match comments against
    *
    * @returns {str[]} - all comments that matched the pattern
    *
    * @throws Error(`Could not get comment list`)
    *
    */

  async iterateThroughSet(client, cursor, pattern){
    try {
      const returnSet = new Set();
      const reply = await client.sscanAsync(this.title, cursor, 'match', pattern);
      returnSet.add(reply[1]);
      return cursor === '0' ? Array.from(returnSet) : this.iterateThroughSet(client, reply[0], pattern)
    } catch (e) {
      throw new Error(`Could not commit comment: ${e}`)
    }
  }

  /**
    * @function getAllComments - returns all comments, by default not including deleted
    *
    * @param {RedisClient} client - active Redis client
    * @param {boolean} includeDeleted - if delteted comments should also be returned
    *
    * @returns {str[]} - all comments
    *
    * @throws Error(`Could not get comment list`)
    *
    */

  async getAllComments(client, includeDeleted=false){
    const pattern = includeDeleted ? "*" : "*:*:*:*:0:*"
    try {
      return this.iterateThroughSet(client, 0, pattern)
    } catch (e) {
      throw new Error(`Could not get comment list: ${e}`)
    }
  }

  /**
    * @function commentExists - helper to check if comment exists in Set
    *
    * @param {RedisClient} client - active Redis client
    * @param {String} id - id of the comment
    *
    * @returns {boolean} - true if the comment exists
    *
    * @throws Error(`Could not determine if ${id} exists`)
    *
    */

  async commentExists(client, id){
    try {
      return await this.iterateThroughSet(client, 0, `${id}:*`) !== 0
    } catch (e) {
      throw new Error(`Could not determine if ${id} exists`)
    }
  }

    /**
    * @function deleteComment - helper to delete a comment Set
    *
    * @param {RedisClient} client - active Redis client
    * @param {String} id - id of the comment
    *
    * @returns {boolean} - true if the comment was deleted
    *
    * @throws Error(`Could not determine if ${id} exists`)
    *
    */

  async deleteComment(client, id){
    try {
      return await this.editComment(client, id, {deleted: 1})
    } catch (e){
      throw new Error(`Could not delete comment for id ${id}`)
    }
  }
}

module.exports = CommentSet
